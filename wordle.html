<!DOCTYPE html>
<html>
<head>
	<meta charset="utf-8" />
	<title>Paradigms Assignment 2</title>
	<style>
   	 * { padding: 0; margin: 0; }
   	 canvas { background: #eee; display: block; margin: 0 auto; }
	</style>
</head>
<body>

<canvas id="myCanvas" width="480" height="720"></canvas>

<script>
    // Cut and paste your jsfiddle javascript code here.
    let textByLine = ["aback", "abase", "abate", "abaya", "abbey", "abbot", "abets", "abhor", "abide", "abode", "abort", "about", "above", "abuse", "abuts", "abyss", "ached", "aches", "acids", "acing", "ackee", "acorn", "acres", "acrid", "acted", "actin", "actor", "acute", "adage", "adapt", "added", "adder", "addle", "adept", "adieu", "adios", "adits", "adman", "admin", "admit", "adobe", "adobo", "adopt", "adore", "adorn", "adult", "adzes", "aegis", "aeons", "aerie", "affix", "afire", "afoot", "afore", "after", "again", "agape", "agate", "agave", "agent", "aggro", "agile", "aging", "aglow", "agony", "agora", "agree", "ahead", "ahold", "aided", "aider", "aides", "ailed", "aimed", "aimer", "aioli", "aired", "aisle", "alarm", "album", "alder", "aleph", "alert", "algae", "algal", "alias", "alibi", "alien", "align", "alike", "alive", "alkyd", "alkyl", "allay", "alley", "allot", "allow", "alloy", "allyl", "aloes", "aloft", "aloha", "alone", "along", "aloof", "aloud", "alpha", "altar", "alter", "altos", "alums", "amass", "amaze", "amber", "ambit", "amble", "ambos", "amend", "amide", "amine", "amino", "amiss", "amity", "amnio", "among", "amour", "amped", "ample", "amply", "amuse", "ancho", "angel", "anger", "angle", "angry", "angst", "anima", "anime", "anion", "anise", "ankle", "annas", "annex", "annoy", "annul", "anode", "anole", "antic", "antis", "antsy", "anvil", "aorta", "apace", "apart", "aphid", "apnea", "apple", "apply", "apron", "apses", "apter", "aptly", "aquas", "arbor", "ardor", "areal", "areas", "areca", "arena", "argon", "argot", "argue", "argus", "arias", "arils", "arise", "armed", "armor", "aroma", "arose", "array", "arrow", "arses", "arson", "artsy", "asana", "ascot", "ashen", "ashes", "aside", "asked", "asker", "askew", "aspen", "aspic", "assay", "asses", "asset", "aster", "astir", "asura", "atlas", "atman", "atoll", "atoms", "atone", "atopy", "attic", "audio", "audit", "auger", "aught", "augur", "aunts", "aunty", "aural", "auras", "autos", "auxin", "avail", "avers", "avert", "avian", "avoid", "avows", "await", "awake", "award", "aware", "awash", "awful", "awoke", "axels", "axial", "axils", "axing", "axiom", "axion", "axles", "axons", "azide", "azole", "azure"];
    let solution = textByLine[Math.floor(Math.random()*textByLine.length)];
    


    const canvas = document.getElementById("myCanvas");
    const ctx = canvas.getContext("2d");

    let keys = new Array(3);

    let currLetter = 0;
    let currLevel = 0;

    let lastDraw = false;

    const lightGray = "#eeeeee";
    const green = "#19d70f";
    const yellow = "#d3d70f";
    const darkGray = "#888888";

    const tileSize = canvas.width/7;
    const textSize = tileSize*2/3;
    const keyboardSize = canvas.width/10;
    const keyboardTextSize = keyboardSize*2/3;

    const errorMessage = 'Not a word in the list'

    const winningStatements = [
        'Genius',
        'Magnificent',
        'Impressive',
        'Splendid',
        'Great',
        'Phew'
    ];

    class Tile {
        constructor(value, row, col, otherTiles){
            this.value = value;
            this.row = row;
            this.col = col;
            this.color = lightGray;
            this.userInput = " ";
            this.size = tileSize;
            this.otherTiles = otherTiles;
        }

        

    }

    Tile.prototype.drawTile = function(){
            ctx.beginPath();
            ctx.rect(this.size*(this.row+1), this.size*(this.col+1.5), this.size, this.size);
            ctx.fillStyle = this.color;
            ctx.fill();
            ctx.closePath();

            ctx.beginPath();
            ctx.font = textSize + "px Arial";
            ctx.fillStyle = "#000000";
            ctx.textAlign = 'center';
            ctx.fillText(this.userInput, this.size*(this.row+1)+this.size/2, this.size*(this.col+1.5)+this.size/1.5);
            ctx.closePath();

    }

    Tile.prototype.checkValue = function(){
        if(this.userInput === this.value){
            this.color = green;
            //keyboard needs to be green
            for(let i = 0; i < keys.length; i++){
                for(let j = 0; j < keys[i].length; j++){
                    if(this.userInput == keys[i][j].value){
                        keys[i][j].color = green;
                        return true;
                    }
                }
            }
        }
        else if(this.otherTiles.indexOf(this.userInput) > -1){
            this.color = yellow;
            //if light gray this becomes yellow
            for(let i = 0; i < keys.length; i++){
                for(let j = 0; j < keys[i].length; j++){
                    if(this.userInput == keys[i][j].value && keys[i][j].color === lightGray){
                        keys[i][j].color = yellow;
                    }
                }
            }
        }
        else {
            this.color = darkGray;
            //keyboard needs to be dark gray
            for(let i = 0; i < keys.length; i++){
                for(let j = 0; j < keys[i].length; j++){
                    if(this.userInput == keys[i][j].value){
                        keys[i][j].color = darkGray;
                    }
                }
            }
        }
        return false;
    }

    class KeyBoardLetter {
        constructor(value, row, col){
            this.value = value;
            this.row = row;
            this.col = col;
            this.x = col*keyboardSize+keyboardSize/2;
            this.y = canvas.height - 3*keyboardSize + row*keyboardSize;
            if(row == 0){
                this.x = col*keyboardSize;
            }
            this.color = lightGray;
            this.size = keyboardSize;
        }
    }

    KeyBoardLetter.prototype.drawLetter = function(){
            ctx.beginPath();
            ctx.rect(this.x, this.y, this.size, this.size);
            ctx.fillStyle = this.color;
            ctx.fill();
            ctx.closePath();

            ctx.beginPath();
            ctx.font = textSize + "px Arial";
            ctx.fillStyle = "#000000";
            ctx.textAlign = 'center';
            ctx.fillText(this.value, this.x+this.size/2, this.y+this.size/1.2);
            ctx.closePath();

    }
    const firstRow = "QWERTYUIOP";
    const secondRow = "ASDFGHJKL";
    const thirdRow = "ZXCVBNM";

    //let keys = new Array(3);

    keys[0] = new Array(firstRow.length);
    for(let i = 0; i < firstRow.length; i++){
        keys[0][i] = new KeyBoardLetter(firstRow[i], 0, i);
    }

    keys[1] = new Array(secondRow.length);
    for(let i = 0; i < secondRow.length; i++){
        keys[1][i] = new KeyBoardLetter(secondRow[i], 1, i);
    }

    keys[2] = new Array(thirdRow.length+2);
    keys[2][0] = new KeyBoardLetter(">", 2, 0);
    keys[2][thirdRow.length+1] = new KeyBoardLetter("<", 2, thirdRow.length+1);
    for(let i = 0; i < thirdRow.length; i++){
        keys[2][i+1] = new KeyBoardLetter(thirdRow[i], 2, i+1);
    }

    //let exampleTile = new Tile("A", 1, 1);
    let tiles = new Array(6);
    //let solution = "APPLE";
    for(let i = 0; i < 6; i++){
        tiles[i] = new Array(solution.length);
        for(let j = 0; j < solution.length; j++){
            tiles[i][j] = new Tile(solution[j], j, i, solution.slice(0, j) + solution.slice(j+1));
            //tiles[i][j] = new Tile(solution[j], j, i);
        }
    }

    function checkValues(guess){
        let correct = true;
        for(let i = 0; i < guess.length; i++){
            if(guess[i].checkValue() === false){
                correct = false;
            }
        }
        return correct;
    }

    window.addEventListener('click', (event) => {
    if (event.button == 0) {
        //alert('X: ' + pointerX + ', Y: ' + pointerY);
        //console.log('Cursor at: ' + pointerX + ', ' + pointerY);
        let done = false;
        for(let i = 0; i < keys.length; i++){
            for(let j = 0; j < keys[i].length; j++){
                if(pointerX > keys[i][j].x && pointerX < keys[i][j].x+keys[i][j].size){
                    if(pointerY > keys[i][j].y && pointerY < keys[i][j].y+keys[i][j].size){
                        //alert(keys[i][j].value);
                        if(keys[i][j].value === '<'){
                            if(currLetter > 0){
                                tiles[currLevel][currLetter-1].userInput = ' ';
                                currLetter--;
                            }
                        }
                        else if(keys[i][j].value === '>'){
                            if(currLetter === 5){
                                currLetter = 0;
                                done = checkValues(tiles[currLevel]);
                                if(done){
                                    break;
                                }
                                currLevel++;
                            }
                            //check function
                        }
                        else if(currLetter < solution.length){
                            tiles[currLevel][currLetter].userInput = keys[i][j].value;
                            currLetter++;
                        }
                    }
                }
            }
        }
        if(done){
            alert(winningStatements[currLevel]);
            lastDraw = true;
            //clearInterval(drawInterval);
            /*document.location.reload();
            clearInterval(interval);*/ // Needed for Chrome to end game

        }
        else if(currLevel > 5){
            alert(solution);
            lastDraw = true;
            //clearInterval(drawInterval);
            //end game
            /*document.location.reload();
            clearInterval(interval);*/ // Needed for Chrome to end game

        }
        }
    })
    // this tracks the value of the x and y coordinates of the mouse
    var pointerX = -1;
    var pointerY = -1;
    document.onmousemove = function(event) {
        pointerX = event.pageX - canvas.offsetLeft;
        pointerY = event.pageY;
    }

    function draw(){
        ctx.beginPath();
        ctx.rect(0, 0, canvas.width, canvas.height);
        ctx.fillStyle = "#000000";
        ctx.fill();
        ctx.closePath();

        ctx.beginPath();
        ctx.font = "30px Arial";
        ctx.fillStyle = "#FFFFFF";
        ctx.textAlign = 'center';
        ctx.fillText("WORDLE", canvas.width/2, canvas.height/10);
        ctx.closePath();

        for(let i = 0; i < tiles.length; i++){
            for(let j = 0; j < tiles[i].length; j++){
                tiles[i][j].drawTile();
            }
        }

        for(let i = 0; i < keys.length; i++){
            for(let j = 0; j < keys[i].length; j++){
                keys[i][j].drawLetter();
            }
        }
        if(lastDraw){
            clearInterval(drawInterval);
        }
    }

    let drawInterval = setInterval(draw, 10);

</script>

</body>
</html>